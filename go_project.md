## 规范设计
- 非编码类规范： 开源规范 文档规范 版本规范 Commit规范 发布规范
- 编码类规范： 目录规范 代码规范 接口规范 日志规范 错误码规范

### 开源规范
- 发布可用的版本：确保每次发布都经过充分测试(详细的单元测试)，每个发布版本都是可用的。
- 合适的git工作流。遵循`Angular commit message`规范。提交记录中不出现内部IP、内部域名、密码、密钥等信息
- `LICENSE`开源软件协议： `GPL`,`MPL`,`LGPL`,`Apache`,`BSD`,`MIT`
- `CONTERIBUTING.md`： 用于说明如何给本项目贡献代码，包含详细贡献流程
- `CHANGELOG`目录： 用于存放版本变更历史
- 详细的文档说明
    + `Maikefile`： 对项目进行构建、测试、安装等操作
    + `README.md`： 包含`项目描述`,`依赖项`,`安装方法`,`使用方法`,`贡献方法`,`作者`,`遵循软件协议`
    + `docs`目录： 存放项目所有文档如 `安装文档`,`使用文档`,`开发文档`
    + `examples`目录： 存放示例代码

## error
- go中没有`try_catch`, 设计者认为将异常与控制结构混在一起会很容易使得代码变得混乱。
- go中使用 error错误类型，panice异常，recover捕获异常，defer退出时执行等关键字或类型对错误进行处理

### 错误处理
- 错误应该只处理一次，做一个决定
- 降级过的错误不应该继续上抛
- 应当优雅减少`Error Handling`。类似`bufio.Scanner`的`Scan()`和`Err()`的联合处理，大大减少了`client`的调用

### 错误的几种定义方式
- `Sentinel Error`特定的错误，类似于`io.Eof`，更底层的有`syscall.ENOENT`。通常是用于开发时的调试，而不是业务开发时的返回
- `Error Type` 实现了`error接口`的自定义类型。如`os.PathError`。可以用`类型断言`或`类型switch`的方式通过`自定义类型`的变量获取更多的上下文
- `Opaque errors` 不透明的错误处理： 只返回错误而不假设其内容，通过行为获取更详细的信息。
    + 如`net.Error`在外部判断时想要更详细的信息可通过`Timeout`等方法获取更详细的信息

### `github.com/pkg/errors` 堆栈错误包
- 可用`errors.Wrap`包装错误，并记录错误堆栈
- 可用`errors.Cause`获取根因，进行断言。
- 在错误产生处返回包装错误，在程序顶部用`%+v`记录堆栈详情
- 仅在业务、项目中使用`pkg/errors`，库中不应该使用。

### go error新特性
- `errors.Is`和`errors.As`参数都可以对实现了`uwrap()`接口的错误进行递归判断

## 日志包设计
### 日志包应具备的功能
- 日志包要具备的功能可分为`基础`、`高级`、`可选`
- 设计日志包要关注的点 `高性能`、`并发安全`、`插件化能力`、`日志参数控制`、

#### 基础功能
- 支持基本日志信息 `时间戳`、`文件名`+`行号`(定位问题)、`级别`(过滤error)、`日志信息`
- 支持不同日志`级别`(由低至高) `trace`(可选的), `debug`, `info`, `warn`, `error`, `panic`(可选的), `fatal`
  + `输出级别` 如`glog.Info("xxx")`指输出级别为`info`
  + `开关级别` 启动应用程序时期望那些`输出级别`的日志被打印，如`开关级别 >= error`则仅记录`error`, `panic`, `fatal`
- 支持自定义配置 如根据不同环境设置不同日志级别，不同情况下输出不同的日志格式
- 支持输出到标准输出和文件

#### 高级功能
- 支持多种日志格式 `text` `json`
- 能按级别分类输出 如错误级别日志单独输出到文件
- 支持`structured logging`(结构化日志)
- 支持`日志轮转` 建议第三方工具实现，如在`Linux`中使用`Logrotate`来轮转日志
- 具备`hook`能力可对日志内容进行自定义处理，如`panic`级别出现时用邮件进行告警
  + 在一个大型系统中，日志告警是非常重要的功能，但更好的实现方式是将告警能力做成旁路功能。通过旁路功能，可以保证日志包功能聚焦、简洁。例如：可以将日志收集到 Elasticsearch，并通过 ElastAlert 进行日志告警。

#### 可选功能
- 支持颜色输出
- 兼容标准库log包
- 支持输出到不同位置 如`elasticsearch` `kafka` `fluentd` `logstash`
  + 也可以通过`filebeat`采集硬盘日志再进行投递


### 日志包的使用(如何记录日志)
#### 使用时机，哪种代码时嵌入
- 在分支语句处打印日志
- 写操作必须打印日志
- 循环中打印日志要慎重 循环打印会降低性能，建议循环中记录要点，循环外总结打印
- 错误产生的最原始位置打印日志，如error一层层上报时仅在最原始层打印错误日志

#### 设置`开关级别`
- `Debug`级别仅在开发调试阶段需要
- `Info`以满足需求为主要目标，不可频度过高(高频度可记录在Debug级别)
- `Warn`通常为`异常但不影响程序运行`的日志，常用于业务级别警告日志
- `Error`错误日志
- `Panic`很少使用，通常在错误堆栈或defer处理错误时使用
- `Fatal`严重错误，通常为系统级别错误，会导致程序无法运行

#### 日志内容
- 不要输出敏感信息 密码、密钥
- 应用Debug日志调试时可用`log.Debugf("XXXXXX-1: input key was: %s", setKeyName)`，调试完成后在找到这些临时日志并删掉。
- 日志内容应`小写字母开头 英文点号结尾`
- 输出时应用明确类型如`%s`而不是`%v`
- 日志应包含`requestID`,`uid`,`行为`

#### 最佳实践
- 支持requestID
- 根据故障排查过程优化日志打印
- 结构化日志记录，添加通用字段在每行日志中
- 支持动态日志输出，如在请求中通过debug=true开启debug日志

#### 分布式日志解决方案(EFK/ELK)
- ELK: Elasticsearch + Logstash + Kibana
- EFK: Elasticsearch + Filebeat + Kibana
- `Filebeat`比`Logstash`更轻量级

